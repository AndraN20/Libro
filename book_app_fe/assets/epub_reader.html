<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <base href="file:///android_asset/flutter_assets/assets/" />
    <style>
      html,
      body {
        width: 100vw !important;
        height: 100vh !important;
        margin: 0;
        padding: 0;
        overflow: hidden !important;
      }
      #viewer {
        width: 100vw !important;
        height: 100vh !important;
        position: fixed !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        background: var(--bg, white);
        box-sizing: border-box;
      }
      #viewer iframe {
        width: 100vw !important;
        height: 100vh !important;
        display: block;
        border: none;
      }
      #prevBtn,
      #nextBtn {
        z-index: 9999;
        font-size: 18px;
        padding: 4px 16px;
      }
    </style>
    <script src="epubjs/jszip.min.js"></script>
    <script src="epubjs/epub.min.js"></script>
    <script>
      const _nativeLog = console.log.bind(console);
      console.log = (...args) => {
        if (window.Console && Console.postMessage)
          Console.postMessage(args.join(" "));
        _nativeLog(...args);
      };
      window.onerror = function (msg, url, line, col, error) {
        console.log("[ERROR]", msg, url, line, col, error);
      };

      let book, rendition;

      function setupNav() {
        document.getElementById("prevBtn").onclick = () => {
          if (rendition) rendition.prev();
        };
        document.getElementById("nextBtn").onclick = () => {
          if (rendition) rendition.next();
        };
      }

      function openBookData(b64, savedCfi) {
        book = ePub(b64, { encoding: "base64" });
        book.ready.then(() => {
          book.locations.generate().then(() => {
            rendition = book.renderTo("viewer", {
              flow: "paginated",
              width: window.innerWidth - 2,
              height: window.innerHeight,
              spread: "none",
              manager: "default",
            });

            // ===== FIX 1: Injectăm CSS să ascundem margin/padding/page-breaks/etc =====
            rendition.hooks.content.register(function (contents) {
              try {
                const doc = contents.document;
                // Set reasonable margins instead of zero
                doc.documentElement.style.margin = "0";
                doc.documentElement.style.padding = "0";
                doc.body.style.margin = "0";
                doc.body.style.padding = "0";
                doc.body.style.background = "#fff";
                // Remove fixed height constraints
                doc.body.style.minHeight = "100%";
                doc.documentElement.style.minHeight = "100%";

                // Injectăm CSS global
                const style = doc.createElement("style");
                style.innerHTML = `
                  * { box-sizing: border-box !important; }
                  body, html { min-height: 100%; }
                  /* Allow page breaks to render properly */
                  .pagenum { display: none !important; }
                  .calibre { margin:0 !important; padding:0 !important; }
                  p, div { orphans: 3; widows: 3; }
                `;
                doc.head.appendChild(style);
              } catch (e) {
                console.log("[HOOK ERROR]", e);
              }
            });

            window.addEventListener("resize", function () {
              if (rendition) {
                // Store current position before resize
                const currentLocation = rendition.currentLocation();
                // Resize the rendition
                rendition.resize(window.innerWidth - 2, window.innerHeight);
                // If we have a location, restore it after resize
                if (currentLocation && currentLocation.start) {
                  setTimeout(() => {
                    rendition.display(currentLocation.start.cfi);
                    console.log(
                      "Restored position after resize:",
                      currentLocation.start.cfi
                    );
                  }, 100);
                }
              }
            });

            const displayCfi =
              typeof savedCfi === "string" && savedCfi.length > 0
                ? savedCfi
                : undefined;
            rendition.display(displayCfi);

            setupNav();

            // Add debug logging for page rendering
            rendition.on("rendered", (section) => {
              console.log("Rendered section:", section.href);
              // Log the content of the rendered section for debugging
              try {
                const iframe = document.querySelector("#viewer iframe");
                if (iframe && iframe.contentDocument) {
                  console.log(
                    "Section content loaded:",
                    iframe.contentDocument.body.children.length,
                    "elements"
                  );
                }
              } catch (e) {
                console.log("Error inspecting content:", e);
              }
            });

            // Add debug logging for page transitions
            rendition.on("displayed", (event) => {
              console.log("Page displayed:", event);
            });

            // Add error logging
            rendition.on("error", (error) => {
              console.log("Rendition error:", error);
            });

            rendition.on("relocated", (location) => {
              console.log(
                "Relocated to:",
                location.start.cfi,
                "Page:",
                location.start.displayed.page
              );
              const cfi = location.start.cfi;
              const percent = book.locations.percentageFromCfi(cfi) || 0;
              if (window.Flutter && Flutter.postMessage) {
                Flutter.postMessage(
                  JSON.stringify({ cfi: cfi, percentage: percent })
                );
              }
            });
          });
        });
      }

      function applySettings(fontSize, fontFamily, bgColor) {
        document.documentElement.style.setProperty("--bg", bgColor || "white");
        const textColor = bgColor && isDark(bgColor) ? "white" : "black";
        document.body.style.color = textColor;
        document.body.style.background = bgColor || "white";
        if (!rendition) return;
        rendition.themes.fontSize(fontSize + "px");
        if (fontFamily) rendition.themes.font(fontFamily);
        rendition.themes.register("custom", {
          body: {
            background: bgColor || "white",
            color: textColor,
          },
        });
        rendition.themes.select("custom");
      }
      function isDark(hexColor) {
        const rgb = hexToRgb(hexColor);
        if (!rgb) return false;
        const [r, g, b] = rgb;
        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
        return luminance < 128;
      }
      function hexToRgb(hex) {
        const cleanHex = hex.replace("#", "");
        if (cleanHex.length !== 6) return null;
        const r = parseInt(cleanHex.substring(0, 2), 16);
        const g = parseInt(cleanHex.substring(2, 4), 16);
        const b = parseInt(cleanHex.substring(4, 6), 16);
        return [r, g, b];
      }
    </script>
  </head>
  <body>
    <div id="viewer"></div>
    <button id="prevBtn" style="position: fixed; top: 20px; left: 20px">
      Prev
    </button>
    <button id="nextBtn" style="position: fixed; top: 20px; left: 80px">
      Next
    </button>
  </body>
</html>
